<?php
namespace Drest;

use Doctrine\Common\Inflector\Inflector;
use Doctrine\ORM\EntityManager;
use Doctrine\ORM\Mapping\ClassMetadata;
use Doctrine\ORM\Mapping\ClassMetadata as ORMClassMetadata;
use Doctrine\ORM\Mapping\ClassMetadataInfo;
use Zend\Code\Generator;
use Zend\Code\Generator\ClassGenerator as ZendClassGenerator;
use Zend\Code\Generator\MethodGenerator;
use Zend\Code\Generator\ParameterGenerator;

/**
 * Class generator used to create client classes
 * @author Lee
 *
 */
class ClassGenerator
{

    /**
     * Header parameter to look for if a request for class info has be done
     * @var string HEADER_PARAM
     */
    const HEADER_PARAM = 'X-DrestCG';
    const EMPTY_FIELD = 'XEMPTYX';

    /**
     * Param types - used in setter method generators
     * @var integer
     */
    const PARAM_TYPE_ITEM = 1;
    const PARAM_TYPE_RELATION_SINGLE = 2;
    const PARAM_TYPE_RELATION_COLLECTION = 3;

    protected static $createBodyTemplate = '
$objet = new self();
foreach($<paramObjetArray> as $key => $value){
<createRelationObjet>
<spaces>if(method_exists($objet, \'set\'.ucfirst($key))){
<spaces><spaces>$objet->$key = $value;
<spaces>}
}
return $objet;
';
    protected static $createRelationObjetOne = '
<spaces>if($key == \'<nameRelation>\'){
<spaces><spaces>$child = null;
<spaces><spaces>if(!is_null($value)){
<spaces><spaces><spaces>$child = <classRelation>::create($value);
<spaces><spaces>}
<spaces><spaces>$objet->$key = $child;
<spaces><spaces>continue;
<spaces>}';
    protected static $createRelationObjetMany = '
<spaces>if($key == \'<nameRelation>\'){
<spaces><spaces>$children = array();
<spaces><spaces>if(!is_null($value)){
<spaces><spaces><spaces>foreach($value as $child){
<spaces><spaces><spaces><spaces>$children[] = <classRelation>::create($child);
<spaces><spaces><spaces>}
<spaces><spaces>}
<spaces><spaces>$objet->$key = $children;
<spaces><spaces>continue;
<spaces>}';
    /**
     * CG classes generated from routeMetaData
     * @var array $classes - uses className as the key
     */
    protected $classes = array();

    /**
     * Entity manager - required to detect relation types and classNames on expose data
     * @param EntityManager $em
     */
    protected $em;

    /**
     * Create an class generator instance
     * @param EntityManager $em
     */
    public function __construct(EntityManager $em)
    {
        $this->em = $em;
    }

    /**
     * Create a class generator instance from provided route metadata.
     * Each route will generate it's own unique version of the class (as it will have its own exposure definitions)
     * @param  array $classMetadatas
     * @return array $object - an array of ZendClassGenerator objects
     */
    public function create(array $classMetadatas)
    {
        foreach ($classMetadatas as $classMetaData) {
            /* @var \Drest\Mapping\ClassMetaData $classMetaData */
            $expose = array();
            foreach ($classMetaData->getRoutesMetaData() as $routeMetaData) {
                /* @var \Drest\Mapping\RouteMetaData $routeMetaData */
                $expose = array_merge_recursive($expose, $routeMetaData->getExpose());
            }
            $this->recurseParams($expose, $classMetaData->getClassName());

            $this->classes[$classMetaData->getClassName()]->addMethods(array($this->createGetIdentifier($this->em->getClassMetadata($classMetaData->getClassName()))));
            $this->classes[$classMetaData->getClassName()]->addMethods(array($this->createSetIdentifier($this->em->getClassMetadata($classMetaData->getClassName()))));
        }

        serialize($this->classes);
    }

    /**
     * Return the generated classes in serialized form
     * @return string $serialized
     */
    public function serialize()
    {
        return serialize($this->classes);
    }


    /**
     * Recurse the expose parameters - pass the entities full class name (including namespace)
     * @param array  $expose
     * @param string $fullClassName
     */
    protected function recurseParams(array $expose, $fullClassName)
    {
        // get ORM metadata for the current class
        $ormClassMetaData = $this->em->getClassMetadata($fullClassName);

        if (isset($this->classes[$fullClassName])) {
            $cg = $this->classes[$fullClassName];
        } else {
            $cg = new ZendClassGenerator();
            $cg->setName($fullClassName);

            $short = 'This class was generated by the drest-client tool, and should be treated as a plain data object';
            $long = <<<EOT
ANY ALTERATIONS WILL BE OVERWRITTEN if the classes are regenerated
The variables declared are exposed by the rest endpoint provided when generating these classes.
However depending on the operation (GET/POST/PUT etc) used some of these may not be populated / operational.
EOT;
            $docBlock = new Generator\DocBlockGenerator($short, $long);
            $cg->setDocBlock($docBlock);
            $cg->addProperties(array($this->createEmptyConstant($fullClassName, '__'.  str_replace('\\', '_', $cg->getNamespaceName().'_'.$cg->getName()).'__')));
            $cg->addMethods(array($this->getStaticCreateMethod($this->getTargetType($fullClassName), $ormClassMetaData)));
        }

        foreach ($expose as $key => $value) {
            if($value == '*'){
                continue;
            }
            if (is_array($value)) {
                if ($ormClassMetaData->hasAssociation($key)) {
                    $this->handleAssocProperty($key, $cg, $ormClassMetaData);

                    $assocMapping = $ormClassMetaData->getAssociationMapping($key);
                    $this->recurseParams($value, $assocMapping['targetEntity']);
                }
            } else {
                if ($ormClassMetaData->hasAssociation($value)) {
                    // This is an association field with no explicit include fields,
                    // include add data field (no relations)
                    $this->handleAssocProperty($value, $cg, $ormClassMetaData);

                    $assocMapping = $ormClassMetaData->getAssociationMapping($value);
                    $teCmd = $this->em->getClassMetadata($assocMapping['targetEntity']);
                    $this->recurseParams($teCmd->getColumnNames(), $assocMapping['targetEntity']);
                } else {
                    $this->handleNonAssocProperty($value, $cg);
                }
            }
        }

        // If the class is already set, overwrite it with it additional expose fields
        $this->classes[$fullClassName] = $cg;
    }

    private function createGetIdentifier($ormClassMetaData){
        $identifiers = $ormClassMetaData->getIdentifier();
        $method = new Generator\MethodGenerator();
        $method->setDocBlock('@return array ');
        $body = 'return array(';
        foreach($ormClassMetaData->getIdentifier() as $id){
            $body .= '$this->'.$id.',';
        }
        $body .= ');';
        $method->setBody($body);
        $method->setName('getIdentifier');
        return $method;
    }

    private function createSetIdentifier($ormClassMetaData){
        $identifiers = $ormClassMetaData->getIdentifier();
        $method = new Generator\MethodGenerator();
        $method->setParameter(new ParameterGenerator('ids'));
        $body = '';
        foreach($ormClassMetaData->getIdentifier() as $cle => $id){
            $body .= '$this->'.$id.' = $ids['.$cle.'];
            ';
        }
        $method->setBody($body);
        $method->setName('setIdentifier');
        return $method;
    }
    /**
     * Build a ::create() method for each data class
     * @param  string                               $class - The name of the class returned (self)
     * @param ClassMetadata $ormClassMetaData - The ORM class meta data
     * @return MethodGenerator $method
     */
    private function getStaticCreateMethod($class, $ormClassMetadata)
    {
        $method = new Generator\MethodGenerator();
        
        $nameVariable = Inflector::camelize($class).'Array';
        $replacements = array(
            '<paramObjetArray>'   => $nameVariable,
            '<className>'         => $class,
            '<createRelationObjet>' => $this->generateCreateFromAssociationMapping($ormClassMetadata),
            '<spaces>'            => '    '
        );

        $create = str_replace(
            array_keys($replacements),
            array_values($replacements),
            self::$createBodyTemplate
        );
        
        $method->setDocBlock('@param array $'.$nameVariable.'
@return ' . $class . ' $instance');
        $method->setParameter(new ParameterGenerator($nameVariable));
        $method->setBody($create);
        $method->setName('create');
        $method->setStatic(true);

        return $method;
    }
    
    /**
     * @param ClassMetadata $ormClassMetaData - The ORM class meta data
     * @return string
     */
    private function generateCreateFromAssociationMapping($ormClassMetadata){
        $updateObjets = '';
        
        
        foreach ($ormClassMetadata->associationMappings as $associationMapping) {

            $replacements = array(
                '<nameRelation>' => $associationMapping['fieldName'],
                '<classRelation>' => $this->getClassNameFromServerClass($associationMapping['targetEntity'])
            );

            if(($associationMapping['type'] & ClassMetadataInfo::TO_MANY) || (($associationMapping['type'] & ClassMetadataInfo::TO_ONE) && !$associationMapping['isOwningSide'])){
                $template = self::$createRelationObjetMany;
            }else {
                $replacements['<referencedId>'] =$associationMapping['joinColumns'][0]['referencedColumnName'];
                $template = self::$createRelationObjetOne;
            }

            $updateObjets .= str_replace(
                array_keys($replacements),
                array_values($replacements),
                $template
            );
        }

        return $updateObjets;
    }
    /**
     * Create a property instance
     * @param  string                      $name - property name
     * @return Generator\PropertyGenerator $property
     */
    private function createProperty($name, $default)
    {
        $property = new Generator\PropertyGenerator();
        $property->setName($name);
        $property->setDefaultValue($default);
        $property->setVisibility(Generator\AbstractMemberGenerator::FLAG_PUBLIC);

        return $property;
    }
    
    private function createEmptyConstant($name, $default){
        $constant = new Generator\PropertyGenerator('NOT_FETCHED', $default);
        $constant->setConst(true);
        return $constant;
    }

    /**
     * get setter methods for a parameter based on type
     * @param  ZendClassGenerator $cg
     * @param  string                   $name        - the parameter name
     * @param  int                      $type        - The type of parameter to be handled
     * @param  string                   $targetClass - the target class name to be set (only used in relational setters)
     * @return array                    $methods
     */
    private function getSetterMethods(&$cg, $name, $type, $targetClass = null)
    {
        $methods = array();
        switch ($type) {
            case self::PARAM_TYPE_ITEM:
                $method = new Generator\MethodGenerator();
                $method->setDocBlock('@param string $' . $name);

                $method->setParameter(new ParameterGenerator($name));
                $method->setBody('$this->' . $name . ' = $' . $name . ';');

                $method->setName('set' . $this->camelCaseMethodName($name));
                $methods[] = $method;
                
                
                $method = new Generator\MethodGenerator();
                $method->setDocBlock('@return string $' . $name);
                $method->setBody('return $this->' . $name . ';');
                $method->setName('get' . $this->camelCaseMethodName($name));
                $methods[] = $method;
                break;
            case self::PARAM_TYPE_RELATION_SINGLE:
                $method = new Generator\MethodGenerator();
                $method->setDocBlock('@param ' . $targetClass . ' $' . $name);

                //$method->setParameter(new ParameterGenerator($name, $this->getTargetType($targetClass)));
                $method->setParameter(new ParameterGenerator($name));
                $method->setBody('$this->' . $name . ' = $' . $name . ';');
                $method->setName('set' . $this->camelCaseMethodName($name));
                $methods[] = $method;
                
                
                $method = new Generator\MethodGenerator();
                $method->setDocBlock('@return ' . $targetClass . ' $' . $name);
                $method->setBody('return $this->' . $name . ';');
                $method->setName('get' . $this->camelCaseMethodName($name));
                $methods[] = $method;
                break;
            case self::PARAM_TYPE_RELATION_COLLECTION:
                $singledName = Inflector::singularize($name);
                $method = new Generator\MethodGenerator();
                $method->setDocBlock('@param ' . $targetClass . ' $' . $singledName);


                //$method->setParameter(new ParameterGenerator($singledName, $this->getTargetType($targetClass)));
                $method->setParameter(new ParameterGenerator($singledName));

                $method->setBody('$this->' . $name . '[] = $' . $singledName . ';');
                $singleMethodName = 'add' . $this->camelCaseMethodName($singledName);
                $method->setName($singleMethodName);
                $methods[] = $method;

                $pluralName = Inflector::pluralize($name);
                if ($singledName === $pluralName) {
                    // Unable to generate a pluralized collection method
                    break;
                }

                $pluralMethod = new Generator\MethodGenerator();
                $pluralMethod->setDocBlock('@param array $' . $name);

                $pluralMethod->setName('add' . $this->camelCaseMethodName($pluralName));
                $pluralMethod->setParameter(new ParameterGenerator($pluralName, 'array'));
                $body = "foreach (\$$pluralName as \$$singledName) \n{\n";
                $body .= "    \$this->$singleMethodName(\$$singledName);\n}";
                $pluralMethod->setBody($body);

                $methods[] = $pluralMethod;


                $method = new Generator\MethodGenerator();
                $method->setDocBlock('@return array $' . $name);
                $method->setBody('return $this->' . $name . ';');
                $method->setName('get' . $this->camelCaseMethodName($name));
                $methods[] = $method;
                break;
        }

        // All setter methods will return $this
        foreach($methods as $cle => $method){
            if(strpos($method->getName(), 'get') === 0){
                continue;
            }
            /** @var Generator\MethodGenerator $methods [$x] * */
            $docBlock = $method->getDocBlock();
            $docBlock->setShortDescription($docBlock->getShortDescription() . "\n@return " . $cg->getName() . ' $this');
            $methods[$cle]->setDocBlock($docBlock);
            $methods[$cle]->setBody($method->getBody() . "\nreturn \$this;");
        }

        return $methods;
    }

    /**
     * Handle a non associative property
     * @param string                              $name - name of the field
     * @param ZendClassGenerator $cg   - The class generator object to attach to
     */
    private function handleNonAssocProperty($name, ZendClassGenerator &$cg)
    {
        $property = $this->createProperty($name, '__'.  str_replace('\\', '_', $cg->getNamespaceName().'_'.$cg->getName()).'__');
        if (!$cg->hasProperty($name)) {
            $cg->addProperties(array($property));
            $cg->addMethods($this->getSetterMethods($cg, $name, self::PARAM_TYPE_ITEM));
        }
    }

    /**
     * Handle an associative property field
     * @param string                              $name             - name of the field
     * @param ZendClassGenerator $cg               - The class generator object to attach to
     * @param ClassMetadata $ormClassMetaData - The ORM class meta data
     */
    private function handleAssocProperty($name, ZendClassGenerator &$cg, ORMClassMetadata $ormClassMetaData)
    {
        $assocMapping = $ormClassMetaData->getAssociationMapping($name);
        $property = $this->createProperty($name, '__'.  str_replace('\\', '_', $cg->getNamespaceName().'_'.$cg->getName()).'__');

        if ($assocMapping['type'] & $ormClassMetaData::TO_MANY) {
            // This is a collection (should be an Array)
            $property->setDocBlock('@var array $' . $name);
            $paramType = self::PARAM_TYPE_RELATION_COLLECTION;
        } else {
            // This is a single relation
            $property->setDocBlock('@var ' . $this->getClassNameFromServerClass($assocMapping['targetEntity']) . ' $' . $name);
            $paramType = self::PARAM_TYPE_RELATION_SINGLE;
        }

        if (!$cg->hasProperty($name)) {
            $cg->addProperties(array($property));
            $cg->addMethods($this->getSetterMethods($cg, $name, $paramType, $this->getClassNameFromServerClass($assocMapping['targetEntity'])));
        }
    }


    /**
     * camel case a parameter into a suitable method name
     * @param  string $name
     * @return string $name
     */
    private function camelCaseMethodName($name)
    {
        return implode(
            '',
            array_map(
                function ($item) {
                    return ucfirst($item);
                },
                explode('_', $name)
            )
        );
    }

    /**
     * Get the target type class (excludes any namespace)
     * @param  string $targetClass
     * @return string
     */
    private function getTargetType($targetClass)
    {
        $parts = explode('\\', $targetClass);

        return (sizeof($parts) > 1) ? implode('\\', array_slice($parts, 1)) : $targetClass;
    }
    
    protected function getClassNameFromServerClass($class)
    {
        return ($pos = strrpos($class, '\\'))
            ? substr($class, $pos + 1, strlen($class)) : $class;
    }
}
